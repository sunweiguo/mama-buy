本代码仓库是关于[mamabuy笔记](https://github.com/sunweiguo/swgBook/tree/master/mamabuy)的代码仓库。

只是对电商中的核心点做了一些实现。设计以下的知识点：

- 1.`maven`聚合工程的创建
- 2.`zookeeper`+`kafka`+`actuator`做成一个自动从git上拉取配置并刷新
- 3.`shardingJDBC`分库分表中间件的使用
- 4.全局异常处理
- 5.`spring session`+`redis`实现分布式`session`管理，并且探讨了实现原理
- 6.由用户注册问题，延申出如何防止用户名注册重复问题，这里由于是分布式+分表的情况，所以`select...for update`以及唯一索引都不再适用本场景，这里使用`curator`客户端实现的ZK分布式锁。并且探讨了ZK分布式锁的基本原理
- 7.对于分布式ID生成问题，核心点为：唯一+有序，前者要求是必须全局唯一的，后者是基于mysql的存储引擎如何提高查询效率而提出的要求。本文采用`snowflake`算法来实现。
- 8.电商中有一个重要概念叫做`SKU`，即最小库存单位，探讨一下最简单的商品详情页是如何设计`sku`的。
- 9.关于商品信息的全文搜索（搜索框或者点击分类显示这个分类下的所有商品），数据库的模拟查询限制太多：速度慢、匹配问题、全表扫描等问题，这里搭建ELK平台（Elasticsearch、Logstash和Kibana），对商品表的内容进行建立索引，再加上分词器`ik_max_word`，对匹配结果进行排序，展示出来。这里详细说明了ELK平台的搭建过程和测试。最后用`Jest`,客户端编写java代码，在代码层面实现全文搜索功能。
- 10.`spring cache`的基本使用，对于简单的缓存场景可以用这个。
- 针对用户下单扣减库存问题，详细探讨了普通update存在超卖的问题，后续一系列的优化：
   - 乐观锁（多线程竞争性能低）；
   - 悲观锁（性能低，直接锁行，需要排队）；
   - `redis`的`watch`实现的乐观锁，不过`watch`不能再集群环境下使用，限制较多；
   - 用`incrby`原子递增或者递减操作，对于一个变量可以这样实现，但是库存一般都要维护两个变量：库存+锁定库存，前者表示还剩多少库存没有被下单，也没有被支付，是真正可以利用的库存；后者表示被下单的库存，但是还没有支付，如果订单超时，是需要将其收回的。所以一个原子操作是不够的，我们需要一个办法让这两个变量的变化放在一个事务里面。
   - 引出了本文的实现方案：`redis`+`lua`脚本。为什么要用lua呢？可以用lua将一系列操作封装起来执行，输入自己的参数即可。`lua`脚本在`redis`中执行是串行的、原子性的。
- 11.幂等性问题：用户下单除了由于多线程竞争引发超卖问题之外，还有一个问题是幂等性问题，因为下订单往往是通过MQ去异步下订单，如果MQ出现问题，于是进行了重发机制，最后可能导致两次或两次以上去下订单成功，那么一个用户明明就买了一个商品，结果扣掉了两件商品，是不能忍受的。如何解决呢？这里是采用`redis`分布式锁来锁订单号一段时间来解决的。让他在一段时间内锁住，防止由于MQ重发机制导致重复进来扣减库存。由于锁的是每一个订单号，所以性能不会受到影响，一段时间后让锁自动过期失效。
- 12.定时任务，这里采用分布式定时任务`Elastic Job`来实现，这里详细介绍了如何整合，此外，定时任务用处非常多，比如这里用定时任务是扫描哪些订单是超时的，可以去扫描出来去关闭。
- 13.下完订单后可以利用`redis`过期事件回调通知来提高订单超时解决的效率，提早将库存归位，定时扫描再检查。
- 14.复杂的业务场景往往会设计跨库操作，比如多个数据库，比如`redis`和数据库等等，如何保证数据的一致性呢？介绍了两种可行性方案：基于可靠消息服务的分布式事务（目前只有`RocketMQ`消息队列可以实现）和最大努力通知。我们追求的是数据的最终一致性，所以可以容许中间状态的存在。
